/*
 * generated by Xtext
 */
 
 /*
  * Missing constraints:
  * We don't check for the oparand if number are outside the scope of the 'expected' value
  *  
  * if carType = 4-6 && carType = "SlowCar"
 			then carType can 13-14
 			
 			if carType = 5 then
 			carType = 11
  */
package org.xtext.example.mydsl.validation

import configuratorProject.myBinary
import configuratorProject.myBoolean
import configuratorProject.myConstraint
import configuratorProject.myIdentifier
import configuratorProject.myLiteral
import configuratorProject.myNumberEnum
import configuratorProject.myObject
import configuratorProject.myRange
import configuratorProject.myStringEnum
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SmdpDslValidator extends AbstractSmdpDslValidator {
	@Check
	def void constraint(myObject it) {
		// Attribute name must be unique
		if (!(it.myAttributeContains.forall[ attributeName | myAttributeContains.filter[name.equalsIgnoreCase(attributeName.name)].size == 1])){
			error("A attribute should have a unique name", null);
		}
		
		// Checks all if statements that the value exsist in out attribute list
		it.myObjectHas.forall[con | myValuesCheck(con.myIfConstraint as myBinary, it)]
		
		// Checks all then statements that the value exsist in out attribute list
		it.myObjectHas.forall[con | myValuesCheck(con.myThenConstraint as myBinary, it)]
	}

	@Check
	def constraint(myNumberEnum it) {
		if (values.length == 0) {
			error("All number enum must have a size of at least 1", null)
		}
		
		
		// Check that each value is unique
		values.forall[ value | values.filter[it == value].size == 1]	
	}
	def  constraint(myRange it) {
		from < to;
	}
	
	def constraint(myBoolean it) {
		trueValue != falseValue
		
		&&
		
		trueValue != ""
		
		&& 
		
		falseValue != ""
	}
	

	def  constraint (myStringEnum it) { // example
		(values.length > 0) 
		
		&& 
		
		values.forall[s | s != ""]
		
		&&
		
		// Check that each value is unique
		values.forall[ value | values.filter[it == value].size == 1]
	}
	
	 
	  def boolean myValuesCheck(myBinary it, myObject o){
	  	if (it.myBinaryLeft instanceof myBinary){
	  		return myValuesCheck(it.myBinaryLeft as myBinary, o)
	  	}
	  	if (it.myBinaryRight instanceof myBinary){
	  		return myValuesCheck(it.myBinaryRight as myBinary, o)
	  	}
	  	
	  	if (it.myBinaryLeft instanceof myIdentifier) {
			val attributeValue = o.myAttributeContains.findFirst[a | a ==(myBinaryLeft as myIdentifier)].myAttributeContains;
	  		if (attributeValue instanceof myStringEnum) {
	  			return myStringEnumValueCheck(attributeValue as myStringEnum, myBinaryRight as myStringEnum)
	  		}
	  		
	  		if (attributeValue instanceof myNumberEnum){
	  			return myNumberEnumValueCheck(attributeValue as myNumberEnum, myBinaryRight as myNumberEnum)
	  		}
	  		
	  		if (attributeValue instanceof myBoolean){
	  			return myBooleanValueCheck(attributeValue as myBoolean, myBinaryRight as myLiteral)
	  		}
	  		
	  		if (attributeValue instanceof myRange){
	  			return myRangeValueCheck(attributeValue as myRange, myBinaryRight as myNumberEnum)
	  		}
	  	}
	  	return false;
	  }
	  
	  def boolean myStringEnumValueCheck(myStringEnum it, myStringEnum expectedValue){
	  	return it.values.containsAll(expectedValue.values);
	  }
	  
	  def boolean myNumberEnumValueCheck(myNumberEnum it, myNumberEnum expectedValue){
	  	return it.values.containsAll(expectedValue.values);
	  }
	  
	  def boolean myBooleanValueCheck(myBoolean it, myLiteral expectedValue){
	  	return it.trueValue == expectedValue || it.falseValue == expectedValue;
	  }
	  
	  def static boolean myRangeValueCheck(myRange it, myLiteral expectedValue){
	  	if (expectedValue instanceof myNumberEnum) {  	
	  		return it.from <= expectedValue.values.get(0)  && expectedValue.values.get(0)  <= it.to
	  	}
	  	if (expectedValue instanceof myRange){
	  		return it.from <= expectedValue.from && expectedValue.to <= it.to;
	  	}
	  }
}
