/*
 * generated by Xtext
 */
 
 /*
  * Missing constraints:
  * We don't check for the oparand if number are outside the scope of the 'expected' value
  *  
  * if carType = 4-6 && carType = "SlowCar"
 			then carType can 13-14
 			
 			if carType = 5 then
 			carType = 11
  */
package org.xtext.example.mydsl.validation
import org.eclipse.emf.ecore.EObject
import configuratorProject.*;

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SmdpDslValidator extends AbstractSmdpDslValidator {

	def static dispatch constraint(myObject it) {
		// Attribute name must be unique
		it.myAttributeContains.forall[ attributeName | myAttributeContains.filter[it == attributeName].size == 1]
		
		// Checks all if statements that the value exsist in out attribute list
		it.myObjectHas.forall[con | myValuesCheck(con.myIfConstraint as myBinary, it)]
		
		// Checks all then statements that the value exsist in out attribute list
		it.myObjectHas.forall[con | myValuesCheck(con.myThenConstraint as myBinary, it)]
	}


	def static dispatch  constraint(myNumberEnum it) {
		(values.length > 0)
		
		&& 
		// Check that each value is unique
		values.forall[ value | values.filter[it == value].size == 1]	
	}
	def static dispatch  constraint(myRange it) {
		from < to;
	}
	
	def static dispatch  constraint(myBoolean it) {
		trueValue != falseValue
		
		&&
		
		trueValue != ""
		
		&& 
		
		falseValue != ""
	}
	

	def static dispatch  constraint (myStringEnum it) { // example
		(values.length > 0) 
		
		&& 
		
		values.forall[s | s != ""]
		
		&&
		
		// Check that each value is unique
		values.forall[ value | values.filter[it == value].size == 1]
	}
	
	 def static dispatch  constraint (myConstraint it) { // example
	 	//it.myIfConstraint.
	 }
	 
	  def static boolean myValuesCheck(myBinary it, myObject o){
	  	if (it.myBinaryLeft instanceof myBinary){
	  		return myValuesCheck(it.myBinaryLeft as myBinary, o)
	  	}
	  	if (it.myBinaryRight instanceof myBinary){
	  		return myValuesCheck(it.myBinaryRight as myBinary, o)
	  	}
	  	
	  	if (it.myBinaryLeft instanceof myIdentifier) {
			val attributeValue = o.myAttributeContains.findFirst[a | a ==(myBinaryLeft as myIdentifier)].myAttributeContains;
	  		if (attributeValue instanceof myStringEnum) {
	  			return myStringEnumValueCheck(attributeValue as myStringEnum, myBinaryRight as myStringEnum)
	  		}
	  		
	  		if (attributeValue instanceof myNumberEnum){
	  			return myNumberEnumValueCheck(attributeValue as myNumberEnum, myBinaryRight as myNumberEnum)
	  		}
	  		
	  		if (attributeValue instanceof myBoolean){
	  			return myBooleanValueCheck(attributeValue as myBoolean, myBinaryRight as myLiteral)
	  		}
	  		
	  		if (attributeValue instanceof myRange){
	  			return myRangeValueCheck(attributeValue as myRange, myBinaryRight as myNumberEnum)
	  		}
	  	}
	  	return false;
	  }
	  
	  def static boolean myStringEnumValueCheck(myStringEnum it, myStringEnum expectedValue){
	  	return it.values.containsAll(expectedValue.values);
	  }
	  
	  def static boolean myNumberEnumValueCheck(myNumberEnum it, myNumberEnum expectedValue){
	  	return it.values.containsAll(expectedValue.values);
	  }
	  
	  def static boolean myBooleanValueCheck(myBoolean it, myLiteral expectedValue){
	  	return it.trueValue == expectedValue || it.falseValue == expectedValue;
	  }
	  
	  def static boolean myRangeValueCheck(myRange it, myLiteral expectedValue){
	  	if (expectedValue instanceof myNumberEnum) {  	
	  		return it.from <= expectedValue.values.get(0)  && expectedValue.values.get(0)  <= it.to
	  	}
	  	if (expectedValue instanceof myRange){
	  		return it.from <= expectedValue.from && expectedValue.to <= it.to;
	  	}
	  }
}
