/*
 * generated by Xtext
 */
 
 /*
  * Missing constraints:
  * We don't check for the oparand if number are outside the scope of the 'expected' value
  *  
  * if carType = 4-6 && carType = "SlowCar"
 			then carType can 13-14
 			
 			if carType = 5 then
 			carType = 11
  */
package org.xtext.example.mydsl.validation

import configuratorProject.myBinary
import configuratorProject.myBoolean
import configuratorProject.myConstraint
import configuratorProject.myIdentifier
import configuratorProject.myLiteral
import configuratorProject.myNumberEnum
import configuratorProject.myObject
import configuratorProject.myRange
import configuratorProject.myStringEnum
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SmdpDslValidator extends AbstractSmdpDslValidator {
	@Check
	def void constraint(myObject it) {

		// Attribute name must be unique
		if (!(it.myAttributeContains.forall[ attributeName | myAttributeContains.filter[name.equalsIgnoreCase(attributeName.name)].size == 1])){
			error("A attribute should have a unique name", null);
		}
	}
	@Check
	def void constraint(myConstraint it){
		if (!myValuesCheck(myThenConstraint as myBinary, null)) {
			error("Constraint contains illigal values", null)
		}
		
		if (!myValuesCheck(myIfConstraint as myBinary, null)) {
				error("If statements contain a invalid value", null);
		}
	}

	@Check
	def constraint(myNumberEnum it) {
		if (values.length == 0) {
			error("All number enum must have a size of at least 1", null)
		}
		
		// Check that each value is unique
		values.forall[ value | values.filter[it == value].size == 1]	
	}
	@Check
	def constraint(myRange it) {
		if (from > to) {
			error("The start value in a range cannot be larger than the end value", null);
		}
	}	
	@Check
	def constraint(myBoolean it) {
		if (trueValue == falseValue) {
			error("The values for boolean can't be the same", null);
		}
		
		if (trueValue == "" || falseValue == ""){
			error("Boolean must be asigned a value", null);
		}
		
	}	
	@Check
	def  constraint (myStringEnum it) { // example	
		// Check that each value is unique
		it.values.forEach[item | {
			if (values.filter[p1 | p1.equalsIgnoreCase(item)].size > 1) {
				error("String enum does not contain unique values: " + values.filter[p1 | p1.equalsIgnoreCase(item)].size, null);
				}
		}]
	}
	 
	 /* Helper method to go throuh the expression tree, to check if all values are valid
	  * We don't take the operan into account, there for it will be possible to set values that are outside a range scope
	  * if '<' or '>' is used. 
	  */
	  def boolean myValuesCheck(myBinary it, myIdentifier attribute){
	  	// Hvis left er identifyer, find key
	  	info("LEFT:" + it.myBinaryLeft + " - RIGHT: "+ it.myBinaryRight, null)
	  	var boolean leftCorrect = false;
	  	var boolean rightCorrect = false;
	  	var myIdentifier att;
	  	// If left is a identifier, get the attribute
	  	if (it.myBinaryLeft instanceof myIdentifier) {
	  		att = it.myBinaryLeft as myIdentifier;
	  		leftCorrect = true;
	  	} else {
	  		att = attribute;
	  	}
	  	
	  	// If both left and right are binaries, then both sides must be true
	  	if (it.myBinaryLeft instanceof myBinary && it.myBinaryRight instanceof myBinary)	{
	  		return myValuesCheck(it.myBinaryLeft as myBinary, att) && myValuesCheck(it.myBinaryRight as myBinary, att)
	  	}
		
		// If the right is a binary, then go one depth deeper.
	  	if (it.myBinaryRight instanceof myBinary){
	  		return myValuesCheck(it.myBinaryRight as myBinary, att)
	  	}  	
	  	
	  	// Check the values in the left side
	  	if (it.myBinaryLeft instanceof myStringEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		
	  		if (attributeValue instanceof myStringEnum) {
	  			leftCorrect = myStringEnumValueCheck(attributeValue as myStringEnum, myBinaryLeft as myStringEnum)
	  		}
	  		
	  		if (attributeValue instanceof myBoolean){
	  			leftCorrect = myBooleanValueCheck(attributeValue as myBoolean, myBinaryLeft as myStringEnum)
	  		}
	  	}
	  	
	  	if (it.myBinaryLeft instanceof myNumberEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		if (attributeValue instanceof myNumberEnum){
	  			leftCorrect =  myNumberEnumValueCheck(attributeValue as myNumberEnum, myBinaryLeft as myNumberEnum)
	  		}
	  		
	  		if (attributeValue instanceof myRange){
	  			leftCorrect =  myRangeValueCheck(attributeValue as myRange, myBinaryLeft as myNumberEnum)
	  		}
	  	}
	  	
	  	// Check the values in the right side.
	  	if (it.myBinaryRight instanceof myStringEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		
	  		if (attributeValue instanceof myStringEnum) {
	  			rightCorrect = myStringEnumValueCheck(attributeValue as myStringEnum, myBinaryRight as myStringEnum)
	  		}
	  		
	  		if (attributeValue instanceof myBoolean){
	  			rightCorrect = myBooleanValueCheck(attributeValue as myBoolean, myBinaryRight as myStringEnum)
	  		}
	  	}
	  	
	  	if (it.myBinaryRight instanceof myNumberEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		if (attributeValue instanceof myNumberEnum){
	  			rightCorrect = myNumberEnumValueCheck(attributeValue as myNumberEnum, myBinaryRight as myNumberEnum)
	  		}
	  		
	  		if (attributeValue instanceof myRange){
	  			rightCorrect = myRangeValueCheck(attributeValue as myRange, myBinaryRight as myNumberEnum)
	  		}
	  	}
	  		
  	 	if (leftCorrect && rightCorrect) {
  	 		return true
  	 	}  		
	  	return false;
	  }
	  
	  def boolean myStringEnumValueCheck(myStringEnum it, myStringEnum expectedValue){
	  	val res = it.values.containsAll(expectedValue.values)
	  	//warning(""+res, null)
	  	return res;
	  }
	  
	  def boolean myNumberEnumValueCheck(myNumberEnum it, myNumberEnum expectedValue){
	  	val res = it.values.containsAll(expectedValue.values)
	  	//warning(""+res, null)
	  	return res;
	  }
	  
	  def boolean myBooleanValueCheck(myBoolean it, myLiteral expectedValue){
	  	// Apparently the expected value gets mapped to a string enum.
	  	val value = expectedValue as myStringEnum;
	  	
	  	//warning("Expected value" + value.values.get(0), null)
	  	//warning("true value: " + it.trueValue, null)
	  	//warning("false value: " + it.falseValue, null)
	  	val res = it.trueValue.equalsIgnoreCase(value.values.get(0)) || it.falseValue.equalsIgnoreCase(value.values.get(0));
	  	//warning(""+res, null)
	  	return res;
	  }
	  
	  def boolean myRangeValueCheck(myRange it, myLiteral expectedValue){
	  	if (expectedValue instanceof myNumberEnum) {
	  		val res = (it.from <= expectedValue.values.get(0))  && (expectedValue.values.get(0)  <= it.to)
	  		//warning("enum: "+res, null) 	
	  		return res;
	  	}
	  	if (expectedValue instanceof myRange){
	  		val res = it.from <= expectedValue.from && expectedValue.to <= it.to;
	  		//warning("range: "+res, null) 	
	  		return res;
	  	}
	  }
}
