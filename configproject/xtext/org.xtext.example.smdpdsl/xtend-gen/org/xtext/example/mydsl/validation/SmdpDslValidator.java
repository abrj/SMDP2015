/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import configuratorProject.myAttribute;
import configuratorProject.myBinary;
import configuratorProject.myBoolean;
import configuratorProject.myConstraint;
import configuratorProject.myExpression;
import configuratorProject.myIdentifier;
import configuratorProject.myLiteral;
import configuratorProject.myNumberEnum;
import configuratorProject.myObject;
import configuratorProject.myRange;
import configuratorProject.myStringEnum;
import configuratorProject.myValue;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.mydsl.validation.AbstractSmdpDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class SmdpDslValidator extends AbstractSmdpDslValidator {
  @Check
  public void constraint(final myObject it) {
    EList<myAttribute> _myAttributeContains = it.getMyAttributeContains();
    final Function1<myAttribute, Boolean> _function = new Function1<myAttribute, Boolean>() {
      public Boolean apply(final myAttribute attributeName) {
        EList<myAttribute> _myAttributeContains = it.getMyAttributeContains();
        final Function1<myAttribute, Boolean> _function = new Function1<myAttribute, Boolean>() {
          public Boolean apply(final myAttribute it) {
            String _name = it.getName();
            String _name_1 = attributeName.getName();
            return Boolean.valueOf(_name.equalsIgnoreCase(_name_1));
          }
        };
        Iterable<myAttribute> _filter = IterableExtensions.<myAttribute>filter(_myAttributeContains, _function);
        int _size = IterableExtensions.size(_filter);
        return Boolean.valueOf((_size == 1));
      }
    };
    boolean _forall = IterableExtensions.<myAttribute>forall(_myAttributeContains, _function);
    boolean _not = (!_forall);
    if (_not) {
      this.error("A attribute should have a unique name", null);
    }
    EList<myConstraint> _myObjectHas = it.getMyObjectHas();
    final Function1<myConstraint, Boolean> _function_1 = new Function1<myConstraint, Boolean>() {
      public Boolean apply(final myConstraint con) {
        myExpression _myIfConstraint = con.getMyIfConstraint();
        return Boolean.valueOf(SmdpDslValidator.this.myValuesCheck(((myBinary) _myIfConstraint), it));
      }
    };
    boolean _forall_1 = IterableExtensions.<myConstraint>forall(_myObjectHas, _function_1);
    boolean _not_1 = (!_forall_1);
    if (_not_1) {
      this.error("One more more if statements contain a invalid value", null);
    }
    EList<myConstraint> _myObjectHas_1 = it.getMyObjectHas();
    final Function1<myConstraint, Boolean> _function_2 = new Function1<myConstraint, Boolean>() {
      public Boolean apply(final myConstraint con) {
        myExpression _myThenConstraint = con.getMyThenConstraint();
        return Boolean.valueOf(SmdpDslValidator.this.myValuesCheck(((myBinary) _myThenConstraint), it));
      }
    };
    boolean _forall_2 = IterableExtensions.<myConstraint>forall(_myObjectHas_1, _function_2);
    boolean _not_2 = (!_forall_2);
    if (_not_2) {
      this.error("One more more then statements contain a invalid value", null);
    }
  }
  
  @Check
  public boolean constraint(final myNumberEnum it) {
    boolean _xblockexpression = false;
    {
      EList<Double> _values = it.getValues();
      int _length = ((Object[])Conversions.unwrapArray(_values, Object.class)).length;
      boolean _equals = (_length == 0);
      if (_equals) {
        this.error("All number enum must have a size of at least 1", null);
      }
      EList<Double> _values_1 = it.getValues();
      final Function1<Double, Boolean> _function = new Function1<Double, Boolean>() {
        public Boolean apply(final Double value) {
          EList<Double> _values = it.getValues();
          final Function1<Double, Boolean> _function = new Function1<Double, Boolean>() {
            public Boolean apply(final Double it) {
              return Boolean.valueOf(Objects.equal(it, value));
            }
          };
          Iterable<Double> _filter = IterableExtensions.<Double>filter(_values, _function);
          int _size = IterableExtensions.size(_filter);
          return Boolean.valueOf((_size == 1));
        }
      };
      _xblockexpression = IterableExtensions.<Double>forall(_values_1, _function);
    }
    return _xblockexpression;
  }
  
  @Check
  public void constraint(final myRange it) {
    int _from = it.getFrom();
    int _to = it.getTo();
    boolean _lessThan = (_from < _to);
    if (_lessThan) {
      this.error("The start value in a range cannot be larger than the end value", null);
    }
  }
  
  @Check
  public void constraint(final myBoolean it) {
    String _trueValue = it.getTrueValue();
    String _falseValue = it.getFalseValue();
    boolean _equals = Objects.equal(_trueValue, _falseValue);
    if (_equals) {
      this.error("The values for boolean can\'t be the same", null);
    }
    boolean _or = false;
    String _trueValue_1 = it.getTrueValue();
    boolean _equals_1 = Objects.equal(_trueValue_1, "");
    if (_equals_1) {
      _or = true;
    } else {
      String _falseValue_1 = it.getFalseValue();
      boolean _equals_2 = Objects.equal(_falseValue_1, "");
      _or = _equals_2;
    }
    if (_or) {
      this.error("Boolean must be asigned a value", null);
    }
  }
  
  @Check
  public void constraint(final myStringEnum it) {
    EList<String> _values = it.getValues();
    final Consumer<String> _function = new Consumer<String>() {
      public void accept(final String item) {
        EList<String> _values = it.getValues();
        final Function1<String, Boolean> _function = new Function1<String, Boolean>() {
          public Boolean apply(final String p1) {
            return Boolean.valueOf(p1.equalsIgnoreCase(item));
          }
        };
        Iterable<String> _filter = IterableExtensions.<String>filter(_values, _function);
        int _size = IterableExtensions.size(_filter);
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          EList<String> _values_1 = it.getValues();
          final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {
            public Boolean apply(final String p1) {
              return Boolean.valueOf(p1.equalsIgnoreCase(item));
            }
          };
          Iterable<String> _filter_1 = IterableExtensions.<String>filter(_values_1, _function_1);
          int _size_1 = IterableExtensions.size(_filter_1);
          String _plus = ("String enum does not contain unique values: " + Integer.valueOf(_size_1));
          SmdpDslValidator.this.error(_plus, null);
        }
      }
    };
    _values.forEach(_function);
  }
  
  public boolean myValuesCheck(final myBinary it, final myObject o) {
    myExpression _myBinaryLeft = it.getMyBinaryLeft();
    if ((_myBinaryLeft instanceof myBinary)) {
      myExpression _myBinaryLeft_1 = it.getMyBinaryLeft();
      return this.myValuesCheck(((myBinary) _myBinaryLeft_1), o);
    }
    myExpression _myBinaryRight = it.getMyBinaryRight();
    if ((_myBinaryRight instanceof myBinary)) {
      myExpression _myBinaryRight_1 = it.getMyBinaryRight();
      return this.myValuesCheck(((myBinary) _myBinaryRight_1), o);
    }
    myExpression _myBinaryLeft_2 = it.getMyBinaryLeft();
    if ((_myBinaryLeft_2 instanceof myIdentifier)) {
      EList<myAttribute> _myAttributeContains = o.getMyAttributeContains();
      final Function1<myAttribute, Boolean> _function = new Function1<myAttribute, Boolean>() {
        public Boolean apply(final myAttribute a) {
          myExpression _myBinaryLeft = it.getMyBinaryLeft();
          return Boolean.valueOf(Objects.equal(a, ((myIdentifier) _myBinaryLeft)));
        }
      };
      myAttribute _findFirst = IterableExtensions.<myAttribute>findFirst(_myAttributeContains, _function);
      final myValue attributeValue = _findFirst.getMyAttributeContains();
      if ((attributeValue instanceof myStringEnum)) {
        myExpression _myBinaryRight_2 = it.getMyBinaryRight();
        return this.myStringEnumValueCheck(((myStringEnum) attributeValue), ((myStringEnum) _myBinaryRight_2));
      }
      if ((attributeValue instanceof myNumberEnum)) {
        myExpression _myBinaryRight_3 = it.getMyBinaryRight();
        return this.myNumberEnumValueCheck(((myNumberEnum) attributeValue), ((myNumberEnum) _myBinaryRight_3));
      }
      if ((attributeValue instanceof myBoolean)) {
        myExpression _myBinaryRight_4 = it.getMyBinaryRight();
        return this.myBooleanValueCheck(((myBoolean) attributeValue), ((myLiteral) _myBinaryRight_4));
      }
      if ((attributeValue instanceof myRange)) {
        myExpression _myBinaryRight_5 = it.getMyBinaryRight();
        return SmdpDslValidator.myRangeValueCheck(((myRange) attributeValue), ((myNumberEnum) _myBinaryRight_5));
      }
    }
    return false;
  }
  
  public boolean myStringEnumValueCheck(final myStringEnum it, final myStringEnum expectedValue) {
    EList<String> _values = it.getValues();
    EList<String> _values_1 = expectedValue.getValues();
    return _values.containsAll(_values_1);
  }
  
  public boolean myNumberEnumValueCheck(final myNumberEnum it, final myNumberEnum expectedValue) {
    EList<Double> _values = it.getValues();
    EList<Double> _values_1 = expectedValue.getValues();
    return _values.containsAll(_values_1);
  }
  
  public boolean myBooleanValueCheck(final myBoolean it, final myLiteral expectedValue) {
    boolean _or = false;
    String _trueValue = it.getTrueValue();
    boolean _equals = Objects.equal(_trueValue, expectedValue);
    if (_equals) {
      _or = true;
    } else {
      String _falseValue = it.getFalseValue();
      boolean _equals_1 = Objects.equal(_falseValue, expectedValue);
      _or = _equals_1;
    }
    return _or;
  }
  
  public static boolean myRangeValueCheck(final myRange it, final myLiteral expectedValue) {
    if ((expectedValue instanceof myNumberEnum)) {
      boolean _and = false;
      int _from = it.getFrom();
      EList<Double> _values = ((myNumberEnum)expectedValue).getValues();
      Double _get = _values.get(0);
      boolean _lessEqualsThan = (_from <= (_get).doubleValue());
      if (!_lessEqualsThan) {
        _and = false;
      } else {
        EList<Double> _values_1 = ((myNumberEnum)expectedValue).getValues();
        Double _get_1 = _values_1.get(0);
        int _to = it.getTo();
        boolean _lessEqualsThan_1 = ((_get_1).doubleValue() <= _to);
        _and = _lessEqualsThan_1;
      }
      return _and;
    }
    if ((expectedValue instanceof myRange)) {
      boolean _and_1 = false;
      int _from_1 = it.getFrom();
      int _from_2 = ((myRange)expectedValue).getFrom();
      boolean _lessEqualsThan_2 = (_from_1 <= _from_2);
      if (!_lessEqualsThan_2) {
        _and_1 = false;
      } else {
        int _to_1 = ((myRange)expectedValue).getTo();
        int _to_2 = it.getTo();
        boolean _lessEqualsThan_3 = (_to_1 <= _to_2);
        _and_1 = _lessEqualsThan_3;
      }
      return _and_1;
    }
    return false;
  }
}
