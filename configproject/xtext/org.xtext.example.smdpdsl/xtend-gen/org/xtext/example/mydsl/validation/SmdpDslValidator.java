/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import configuratorProject.myAttribute;
import configuratorProject.myBinary;
import configuratorProject.myBinaryOparators;
import configuratorProject.myBoolean;
import configuratorProject.myConstraint;
import configuratorProject.myExpression;
import configuratorProject.myIdentifier;
import configuratorProject.myLiteral;
import configuratorProject.myNumberEnum;
import configuratorProject.myObject;
import configuratorProject.myRange;
import configuratorProject.myStringEnum;
import configuratorProject.myValue;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.mydsl.validation.AbstractSmdpDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class SmdpDslValidator extends AbstractSmdpDslValidator {
  @Check
  public void constraint(final myObject it) {
    EList<myAttribute> _myAttributeContains = it.getMyAttributeContains();
    final Function1<myAttribute, Boolean> _function = new Function1<myAttribute, Boolean>() {
      public Boolean apply(final myAttribute attributeName) {
        EList<myAttribute> _myAttributeContains = it.getMyAttributeContains();
        final Function1<myAttribute, Boolean> _function = new Function1<myAttribute, Boolean>() {
          public Boolean apply(final myAttribute it) {
            String _name = it.getName();
            String _name_1 = attributeName.getName();
            return Boolean.valueOf(_name.equalsIgnoreCase(_name_1));
          }
        };
        Iterable<myAttribute> _filter = IterableExtensions.<myAttribute>filter(_myAttributeContains, _function);
        int _size = IterableExtensions.size(_filter);
        return Boolean.valueOf((_size == 1));
      }
    };
    boolean _forall = IterableExtensions.<myAttribute>forall(_myAttributeContains, _function);
    boolean _not = (!_forall);
    if (_not) {
      this.error("A attribute should have a unique name", null);
    }
  }
  
  @Check
  public void constraint(final myConstraint it) {
    myExpression _myThenConstraint = it.getMyThenConstraint();
    boolean _myValuesCheck = this.myValuesCheck(((myBinary) _myThenConstraint), null);
    boolean _not = (!_myValuesCheck);
    if (_not) {
      myExpression _myThenConstraint_1 = it.getMyThenConstraint();
      this.error("Constraint contains illigal values", _myThenConstraint_1, null);
    }
    myExpression _myIfConstraint = it.getMyIfConstraint();
    boolean _myValuesCheck_1 = this.myValuesCheck(((myBinary) _myIfConstraint), null);
    boolean _not_1 = (!_myValuesCheck_1);
    if (_not_1) {
      myExpression _myIfConstraint_1 = it.getMyIfConstraint();
      this.error("If statements contain a invalid value", _myIfConstraint_1, null);
    }
  }
  
  @Check
  public void constraint(final myNumberEnum it) {
    EList<Double> _values = it.getValues();
    int _length = ((Object[])Conversions.unwrapArray(_values, Object.class)).length;
    boolean _equals = (_length == 0);
    if (_equals) {
      this.error("All number enum must have a size of at least 1", it, null);
    }
  }
  
  @Check
  public void constraint(final myRange it) {
    int _from = it.getFrom();
    int _to = it.getTo();
    boolean _greaterThan = (_from > _to);
    if (_greaterThan) {
      this.error("The start value in a range cannot be larger than the end value", it, null);
    }
  }
  
  @Check
  public void constraint(final myBoolean it) {
    String _trueValue = it.getTrueValue();
    String _falseValue = it.getFalseValue();
    boolean _equals = Objects.equal(_trueValue, _falseValue);
    if (_equals) {
      this.error("The values for boolean can\'t be the same", it, null);
    }
    boolean _or = false;
    String _trueValue_1 = it.getTrueValue();
    boolean _equals_1 = Objects.equal(_trueValue_1, "");
    if (_equals_1) {
      _or = true;
    } else {
      String _falseValue_1 = it.getFalseValue();
      boolean _equals_2 = Objects.equal(_falseValue_1, "");
      _or = _equals_2;
    }
    if (_or) {
      this.error("Boolean must be asigned a value", it, null);
    }
  }
  
  @Check
  public void constraint(final myStringEnum it) {
    EList<String> _values = it.getValues();
    int _length = ((Object[])Conversions.unwrapArray(_values, Object.class)).length;
    boolean _equals = (_length == 0);
    if (_equals) {
      this.error("String enum must contain a value", it, null);
    }
  }
  
  /**
   * Helper method to go throuh the expression tree, to check if all values are valid
   * We don't take the operan into account, there for it will be possible to set values that are outside a range scope
   * if '<' or '>' is used.
   */
  public boolean myValuesCheck(final myBinary it, final myIdentifier attribute) {
    myExpression _myBinaryLeft = it.getMyBinaryLeft();
    String _plus = ("LEFT:" + _myBinaryLeft);
    String _plus_1 = (_plus + " - RIGHT: ");
    myExpression _myBinaryRight = it.getMyBinaryRight();
    String _plus_2 = (_plus_1 + _myBinaryRight);
    this.info(_plus_2, null);
    boolean leftCorrect = false;
    boolean rightCorrect = false;
    myIdentifier att = null;
    myExpression _myBinaryLeft_1 = it.getMyBinaryLeft();
    if ((_myBinaryLeft_1 instanceof myIdentifier)) {
      myExpression _myBinaryLeft_2 = it.getMyBinaryLeft();
      att = ((myIdentifier) _myBinaryLeft_2);
      leftCorrect = true;
    } else {
      att = attribute;
    }
    boolean _and = false;
    myExpression _myBinaryLeft_3 = it.getMyBinaryLeft();
    if (!(_myBinaryLeft_3 instanceof myBinary)) {
      _and = false;
    } else {
      myExpression _myBinaryRight_1 = it.getMyBinaryRight();
      _and = (_myBinaryRight_1 instanceof myBinary);
    }
    if (_and) {
      boolean _and_1 = false;
      myExpression _myBinaryLeft_4 = it.getMyBinaryLeft();
      boolean _myValuesCheck = this.myValuesCheck(((myBinary) _myBinaryLeft_4), att);
      if (!_myValuesCheck) {
        _and_1 = false;
      } else {
        myExpression _myBinaryRight_2 = it.getMyBinaryRight();
        boolean _myValuesCheck_1 = this.myValuesCheck(((myBinary) _myBinaryRight_2), att);
        _and_1 = _myValuesCheck_1;
      }
      return _and_1;
    }
    myExpression _myBinaryRight_3 = it.getMyBinaryRight();
    if ((_myBinaryRight_3 instanceof myBinary)) {
      myExpression _myBinaryRight_4 = it.getMyBinaryRight();
      return this.myValuesCheck(((myBinary) _myBinaryRight_4), att);
    }
    myExpression _myBinaryLeft_5 = it.getMyBinaryLeft();
    if ((_myBinaryLeft_5 instanceof myStringEnum)) {
      myAttribute _myIntentifierIs = att.getMyIntentifierIs();
      final myValue attributeValue = _myIntentifierIs.getMyAttributeContains();
      if ((attributeValue instanceof myStringEnum)) {
        myExpression _myBinaryLeft_6 = it.getMyBinaryLeft();
        boolean _myStringEnumValueCheck = this.myStringEnumValueCheck(((myStringEnum) attributeValue), ((myStringEnum) _myBinaryLeft_6));
        leftCorrect = _myStringEnumValueCheck;
      }
      if ((attributeValue instanceof myBoolean)) {
        myExpression _myBinaryLeft_7 = it.getMyBinaryLeft();
        boolean _myBooleanValueCheck = this.myBooleanValueCheck(((myBoolean) attributeValue), ((myStringEnum) _myBinaryLeft_7));
        leftCorrect = _myBooleanValueCheck;
      }
      myBinaryOparators _oparand = it.getOparand();
      boolean _notEquals = (!Objects.equal(_oparand, myBinaryOparators.OR));
      if (_notEquals) {
        this.error("Operand cannot be other than \'|\'", it, null);
        leftCorrect = false;
      }
    }
    myExpression _myBinaryLeft_8 = it.getMyBinaryLeft();
    if ((_myBinaryLeft_8 instanceof myNumberEnum)) {
      myAttribute _myIntentifierIs_1 = att.getMyIntentifierIs();
      final myValue attributeValue_1 = _myIntentifierIs_1.getMyAttributeContains();
      if ((attributeValue_1 instanceof myNumberEnum)) {
        myExpression _myBinaryLeft_9 = it.getMyBinaryLeft();
        boolean _myNumberEnumValueCheck = this.myNumberEnumValueCheck(((myNumberEnum) attributeValue_1), ((myNumberEnum) _myBinaryLeft_9));
        leftCorrect = _myNumberEnumValueCheck;
      }
      if ((attributeValue_1 instanceof myRange)) {
        myExpression _myBinaryLeft_10 = it.getMyBinaryLeft();
        boolean _myRangeValueCheck = this.myRangeValueCheck(((myRange) attributeValue_1), ((myNumberEnum) _myBinaryLeft_10));
        leftCorrect = _myRangeValueCheck;
      }
    }
    myExpression _myBinaryRight_5 = it.getMyBinaryRight();
    if ((_myBinaryRight_5 instanceof myStringEnum)) {
      myAttribute _myIntentifierIs_2 = att.getMyIntentifierIs();
      final myValue attributeValue_2 = _myIntentifierIs_2.getMyAttributeContains();
      if ((attributeValue_2 instanceof myStringEnum)) {
        myExpression _myBinaryRight_6 = it.getMyBinaryRight();
        boolean _myStringEnumValueCheck_1 = this.myStringEnumValueCheck(((myStringEnum) attributeValue_2), ((myStringEnum) _myBinaryRight_6));
        rightCorrect = _myStringEnumValueCheck_1;
      }
      if ((attributeValue_2 instanceof myBoolean)) {
        myExpression _myBinaryRight_7 = it.getMyBinaryRight();
        boolean _myBooleanValueCheck_1 = this.myBooleanValueCheck(((myBoolean) attributeValue_2), ((myStringEnum) _myBinaryRight_7));
        rightCorrect = _myBooleanValueCheck_1;
      }
    }
    myExpression _myBinaryRight_8 = it.getMyBinaryRight();
    if ((_myBinaryRight_8 instanceof myNumberEnum)) {
      myAttribute _myIntentifierIs_3 = att.getMyIntentifierIs();
      final myValue attributeValue_3 = _myIntentifierIs_3.getMyAttributeContains();
      if ((attributeValue_3 instanceof myNumberEnum)) {
        myExpression _myBinaryRight_9 = it.getMyBinaryRight();
        boolean _myNumberEnumValueCheck_1 = this.myNumberEnumValueCheck(((myNumberEnum) attributeValue_3), ((myNumberEnum) _myBinaryRight_9));
        rightCorrect = _myNumberEnumValueCheck_1;
      }
      if ((attributeValue_3 instanceof myRange)) {
        myExpression _myBinaryRight_10 = it.getMyBinaryRight();
        boolean _myRangeValueCheck_1 = this.myRangeValueCheck(((myRange) attributeValue_3), ((myNumberEnum) _myBinaryRight_10));
        rightCorrect = _myRangeValueCheck_1;
      }
    }
    if ((leftCorrect && rightCorrect)) {
      return true;
    }
    return false;
  }
  
  public boolean myStringEnumValueCheck(final myStringEnum it, final myStringEnum expectedValue) {
    EList<String> _values = it.getValues();
    EList<String> _values_1 = expectedValue.getValues();
    final boolean res = _values.containsAll(_values_1);
    return res;
  }
  
  public boolean myNumberEnumValueCheck(final myNumberEnum it, final myNumberEnum expectedValue) {
    EList<Double> _values = it.getValues();
    EList<Double> _values_1 = expectedValue.getValues();
    final boolean res = _values.containsAll(_values_1);
    return res;
  }
  
  public boolean myBooleanValueCheck(final myBoolean it, final myLiteral expectedValue) {
    final myStringEnum value = ((myStringEnum) expectedValue);
    boolean _or = false;
    String _trueValue = it.getTrueValue();
    EList<String> _values = value.getValues();
    String _get = _values.get(0);
    boolean _equalsIgnoreCase = _trueValue.equalsIgnoreCase(_get);
    if (_equalsIgnoreCase) {
      _or = true;
    } else {
      String _falseValue = it.getFalseValue();
      EList<String> _values_1 = value.getValues();
      String _get_1 = _values_1.get(0);
      boolean _equalsIgnoreCase_1 = _falseValue.equalsIgnoreCase(_get_1);
      _or = _equalsIgnoreCase_1;
    }
    final boolean res = _or;
    return res;
  }
  
  public boolean myRangeValueCheck(final myRange it, final myLiteral expectedValue) {
    if ((expectedValue instanceof myNumberEnum)) {
      boolean _and = false;
      int _from = it.getFrom();
      EList<Double> _values = ((myNumberEnum)expectedValue).getValues();
      Double _get = _values.get(0);
      boolean _lessEqualsThan = (_from <= (_get).doubleValue());
      if (!_lessEqualsThan) {
        _and = false;
      } else {
        EList<Double> _values_1 = ((myNumberEnum)expectedValue).getValues();
        Double _get_1 = _values_1.get(0);
        int _to = it.getTo();
        boolean _lessEqualsThan_1 = ((_get_1).doubleValue() <= _to);
        _and = _lessEqualsThan_1;
      }
      final boolean res = _and;
      return res;
    }
    if ((expectedValue instanceof myRange)) {
      boolean _and_1 = false;
      int _from_1 = it.getFrom();
      int _from_2 = ((myRange)expectedValue).getFrom();
      boolean _lessEqualsThan_2 = (_from_1 <= _from_2);
      if (!_lessEqualsThan_2) {
        _and_1 = false;
      } else {
        int _to_1 = ((myRange)expectedValue).getTo();
        int _to_2 = it.getTo();
        boolean _lessEqualsThan_3 = (_to_1 <= _to_2);
        _and_1 = _lessEqualsThan_3;
      }
      final boolean res_1 = _and_1;
      return res_1;
    }
    return false;
  }
}
