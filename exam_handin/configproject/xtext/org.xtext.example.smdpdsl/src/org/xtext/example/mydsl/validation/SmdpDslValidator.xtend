/*
 * generated by Xtext
 */
 
 /*
  * Missing constraints:
  * We don't check for the oparand if number are outside the scope of the 'expected' value
  *  
  * if carType = 4-6 && carType = "SlowCar"
 			then carType can 13-14
 			
 			if carType = 5 then
 			carType = 11
  */
package org.xtext.example.mydsl.validation

import configuratorProject.myBinary
import configuratorProject.myBinaryOparators
import configuratorProject.myBoolean
import configuratorProject.myConstraint
import configuratorProject.myIdentifier
import configuratorProject.myNumberEnum
import configuratorProject.myObject
import configuratorProject.myRange
import configuratorProject.myStringEnum
import configuratorProject.myLiteral
import org.eclipse.xtext.validation.Check
import configuratorProject.ConfiguratorProjectPackage

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class SmdpDslValidator extends AbstractSmdpDslValidator {
	@Check
	def boolean constraint(myObject it) {
		try {
			// Attribute name must be unique
		if (!(it.myAttributeContains.forall[ attributeName | myAttributeContains.filter[name.equalsIgnoreCase(attributeName.name)].size == 1])){
			error("A attribute should have a unique name", null);
		}
		return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		
	}
	@Check
	def boolean constraint(myConstraint it){
		// Checks the then part of 
		try {
			if (!myValuesCheck(myThenConstraint as myBinary, null)) {
			error("Constraint contains illigal values", myThenConstraint, null)
		}
		
		if (!myValuesCheck(myIfConstraint as myBinary, null)) {
				error("If statements contain a invalid value", myIfConstraint, null);
		}
		return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		
	}

	@Check
	def boolean constraint(myNumberEnum it) {
		try {
			if (values.length == 0) {
			error("All number enum must have a size of at least 1", it, null)
		}
		return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	@Check
	def boolean constraint(myRange it) {
		try {
			if (from > to) {
			error("The start value in a range cannot be larger than the end value", it, null);
		}
		return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		
	}	
	@Check
	def boolean constraint(myBoolean it) {
		try {
			if (trueValue == falseValue) {
			error("The values for boolean can't be the same", it, null);
		}
		
		if (trueValue == "" || falseValue == ""){
			error("Boolean must be asigned a value",it, null);
		}
		
		return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}	
	@Check
	def boolean constraint (myStringEnum it) {
		try {
			if (values.length == 0 || values.exists[v | v.equalsIgnoreCase("")]) {
				error("String enum must contain a value",it, null)	
			}
			return true
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	 
	 /* Helper method to go throuh the expression tree, to check if all values are valid
	  * We don't take the operan into account, there for it will be possible to set values that are outside a range scope
	  * if '<' or '>' is used. 
	  */
	  def boolean myValuesCheck(myBinary it, myIdentifier attribute){
	  	var boolean leftCorrect = false;
	  	var boolean rightCorrect = false;
	  	var myIdentifier att;
	  	// If left is a identifier, get the attribute
	  	if (it.myBinaryLeft instanceof myIdentifier) {
	  		att = it.myBinaryLeft as myIdentifier;
	  		leftCorrect = true;
	  	} else {
	  		att = attribute;
	  	}
	  	
	  	// If both left and right are binaries, then both sides must be true
	  	if (it.myBinaryLeft instanceof myBinary && it.myBinaryRight instanceof myBinary)	{
	  		return myValuesCheck(it.myBinaryLeft as myBinary, att) && myValuesCheck(it.myBinaryRight as myBinary, att)
	  	}
		
		// If the right is a binary, then go one depth deeper.
	  	if (it.myBinaryRight instanceof myBinary){
	  		return myValuesCheck(it.myBinaryRight as myBinary, att)
	  	}  	
	  	//region Check the values in the left side
	  	if (it.myBinaryLeft instanceof myStringEnum) {
	  		// If the left is a string, then the value must either be a StringEnum or a Boolean
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		
	  		if (attributeValue instanceof myStringEnum) {
	  			leftCorrect = myStringEnumValueCheck(attributeValue as myStringEnum, myBinaryLeft as myStringEnum)
	  		}
	  		
	  		if (attributeValue instanceof myBoolean){
	  			leftCorrect = myBooleanValueCheck(attributeValue as myBoolean, myBinaryLeft as myStringEnum)
	  		}
	  		
	  		if (it.oparand != myBinaryOparators.OR) {
	  			error("Operand cannot be other than '|'",it,null)
	  			leftCorrect = false;
	  		}
	  	}
	  	
	  	if (it.myBinaryLeft instanceof myNumberEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		// If the left is a number, then the value must either be a NumberEnum or a Range
	  		if (attributeValue instanceof myNumberEnum){
	  			leftCorrect =  myNumberEnumValueCheck(attributeValue as myNumberEnum, myBinaryLeft as myNumberEnum)
	  		}
	  		
	  		if (attributeValue instanceof myRange){
	  			leftCorrect =  myRangeValueCheck(attributeValue as myRange, myBinaryLeft as myNumberEnum)
	  		}
	  	}
	  	//endregion
	  	
	  	//region Check the values in the right side
	  	if (it.myBinaryRight instanceof myStringEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		
	  		if (attributeValue instanceof myStringEnum) {
	  			rightCorrect = myStringEnumValueCheck(attributeValue as myStringEnum, myBinaryRight as myStringEnum)
	  		}
	  		
	  		if (attributeValue instanceof myBoolean){
	  			rightCorrect = myBooleanValueCheck(attributeValue as myBoolean, myBinaryRight as myStringEnum)
	  		}
	  	}
	  	
	  	if (it.myBinaryRight instanceof myNumberEnum) {
	  		val attributeValue = att.myIntentifierIs.myAttributeContains;
	  		if (attributeValue instanceof myNumberEnum){
	  			rightCorrect = myNumberEnumValueCheck(attributeValue as myNumberEnum, myBinaryRight as myNumberEnum)
	  		}
	  		
	  		if (attributeValue instanceof myRange){
	  			rightCorrect = myRangeValueCheck(attributeValue as myRange, myBinaryRight as myNumberEnum)
	  		}
	  	}
	  	//endregion
	  	
	  	// Check that both right, and left side is true	
  	 	if (leftCorrect && rightCorrect) {
  	 		return true
  	 	}  		
	  	return false;
	  }
	  
	  def boolean myStringEnumValueCheck(myStringEnum it, myStringEnum expectedValue){
	  	val res = it.values.containsAll(expectedValue.values)
	  	return res;
	  }
	  
	  def boolean myNumberEnumValueCheck(myNumberEnum it, myNumberEnum expectedValue){
	  	val res = it.values.containsAll(expectedValue.values)
	  	return res;
	  }
	  
	  def boolean myBooleanValueCheck(myBoolean it, myLiteral expectedValue){
	  	// Apparently the expected value gets mapped to a string enum.
	  	val value = expectedValue as myStringEnum;
	  	val res = it.trueValue.equalsIgnoreCase(value.values.get(0)) || it.falseValue.equalsIgnoreCase(value.values.get(0));
	  	return res;
	  }
	  
	  def boolean myRangeValueCheck(myRange it, myLiteral expectedValue){
	  	  	if (expectedValue instanceof myNumberEnum) {
	  		val res = expectedValue.values.forall[v | it.from <= v  && v <= it.to]
	  		return res;
	  	}
	  	if (expectedValue instanceof myRange){
	  		val res = it.from <= expectedValue.from && expectedValue.to <= it.to;
	  		return res;
	  	}
	  	return false;
	  }
}