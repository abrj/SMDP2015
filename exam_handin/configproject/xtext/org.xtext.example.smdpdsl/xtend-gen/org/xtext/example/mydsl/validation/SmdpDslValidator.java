/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import configuratorProject.myAttribute;
import configuratorProject.myBinary;
import configuratorProject.myBinaryOparators;
import configuratorProject.myBoolean;
import configuratorProject.myConstraint;
import configuratorProject.myExpression;
import configuratorProject.myIdentifier;
import configuratorProject.myLiteral;
import configuratorProject.myNumberEnum;
import configuratorProject.myObject;
import configuratorProject.myRange;
import configuratorProject.myStringEnum;
import configuratorProject.myValue;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.mydsl.validation.AbstractSmdpDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class SmdpDslValidator extends AbstractSmdpDslValidator {
  @Check
  public boolean constraint(final myObject it) {
    try {
      EList<myAttribute> _myAttributeContains = it.getMyAttributeContains();
      final Function1<myAttribute, Boolean> _function = (myAttribute attributeName) -> {
        EList<myAttribute> _myAttributeContains_1 = it.getMyAttributeContains();
        final Function1<myAttribute, Boolean> _function_1 = (myAttribute it_1) -> {
          String _name = it_1.getName();
          String _name_1 = attributeName.getName();
          return Boolean.valueOf(_name.equalsIgnoreCase(_name_1));
        };
        Iterable<myAttribute> _filter = IterableExtensions.<myAttribute>filter(_myAttributeContains_1, _function_1);
        int _size = IterableExtensions.size(_filter);
        return Boolean.valueOf((_size == 1));
      };
      boolean _forall = IterableExtensions.<myAttribute>forall(_myAttributeContains, _function);
      boolean _not = (!_forall);
      if (_not) {
        this.error("A attribute should have a unique name", null);
      }
      return true;
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        e.printStackTrace();
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public boolean constraint(final myConstraint it) {
    try {
      myExpression _myThenConstraint = it.getMyThenConstraint();
      boolean _myValuesCheck = this.myValuesCheck(((myBinary) _myThenConstraint), null);
      boolean _not = (!_myValuesCheck);
      if (_not) {
        myExpression _myThenConstraint_1 = it.getMyThenConstraint();
        this.error("Constraint contains illigal values", _myThenConstraint_1, null);
      }
      myExpression _myIfConstraint = it.getMyIfConstraint();
      boolean _myValuesCheck_1 = this.myValuesCheck(((myBinary) _myIfConstraint), null);
      boolean _not_1 = (!_myValuesCheck_1);
      if (_not_1) {
        myExpression _myIfConstraint_1 = it.getMyIfConstraint();
        this.error("If statements contain a invalid value", _myIfConstraint_1, null);
      }
      return true;
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        e.printStackTrace();
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public boolean constraint(final myNumberEnum it) {
    throw new Error("Unresolved compilation problems:"
      + "\nAmbiguous feature call.\nThe extension methods\n\tlength(Object[]) in ArrayExtensions and\n\tlength(double[]) in ArrayExtensions\nboth match.");
  }
  
  @Check
  public boolean constraint(final myRange it) {
    try {
      int _from = it.getFrom();
      int _to = it.getTo();
      boolean _greaterThan = (_from > _to);
      if (_greaterThan) {
        this.error("The start value in a range cannot be larger than the end value", it, null);
      }
      return true;
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        e.printStackTrace();
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public boolean constraint(final myBoolean it) {
    try {
      String _trueValue = it.getTrueValue();
      String _falseValue = it.getFalseValue();
      boolean _equals = Objects.equal(_trueValue, _falseValue);
      if (_equals) {
        this.error("The values for boolean can\'t be the same", it, null);
      }
      boolean _or = false;
      String _trueValue_1 = it.getTrueValue();
      boolean _equals_1 = Objects.equal(_trueValue_1, "");
      if (_equals_1) {
        _or = true;
      } else {
        String _falseValue_1 = it.getFalseValue();
        boolean _equals_2 = Objects.equal(_falseValue_1, "");
        _or = _equals_2;
      }
      if (_or) {
        this.error("Boolean must be asigned a value", it, null);
      }
      return true;
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        e.printStackTrace();
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public boolean constraint(final myStringEnum it) {
    try {
      boolean _or = false;
      EList<String> _values = it.getValues();
      int _length = ((Object[])Conversions.unwrapArray(_values, Object.class)).length;
      boolean _equals = (_length == 0);
      if (_equals) {
        _or = true;
      } else {
        EList<String> _values_1 = it.getValues();
        final Function1<String, Boolean> _function = (String v) -> {
          return Boolean.valueOf(v.equalsIgnoreCase(""));
        };
        boolean _exists = IterableExtensions.<String>exists(_values_1, _function);
        _or = _exists;
      }
      if (_or) {
        this.error("String enum must contain a value", it, null);
      }
      return true;
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        e.printStackTrace();
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  /**
   * Helper method to go throuh the expression tree, to check if all values are valid
   * We don't take the operan into account, there for it will be possible to set values that are outside a range scope
   * if '<' or '>' is used.
   */
  public boolean myValuesCheck(final myBinary it, final myIdentifier attribute) {
    boolean leftCorrect = false;
    boolean rightCorrect = false;
    myIdentifier att = null;
    myExpression _myBinaryLeft = it.getMyBinaryLeft();
    if ((_myBinaryLeft instanceof myIdentifier)) {
      myExpression _myBinaryLeft_1 = it.getMyBinaryLeft();
      att = ((myIdentifier) _myBinaryLeft_1);
      leftCorrect = true;
    } else {
      att = attribute;
    }
    boolean _and = false;
    myExpression _myBinaryLeft_2 = it.getMyBinaryLeft();
    if (!(_myBinaryLeft_2 instanceof myBinary)) {
      _and = false;
    } else {
      myExpression _myBinaryRight = it.getMyBinaryRight();
      _and = (_myBinaryRight instanceof myBinary);
    }
    if (_and) {
      boolean _and_1 = false;
      myExpression _myBinaryLeft_3 = it.getMyBinaryLeft();
      boolean _myValuesCheck = this.myValuesCheck(((myBinary) _myBinaryLeft_3), att);
      if (!_myValuesCheck) {
        _and_1 = false;
      } else {
        myExpression _myBinaryRight_1 = it.getMyBinaryRight();
        boolean _myValuesCheck_1 = this.myValuesCheck(((myBinary) _myBinaryRight_1), att);
        _and_1 = _myValuesCheck_1;
      }
      return _and_1;
    }
    myExpression _myBinaryRight_2 = it.getMyBinaryRight();
    if ((_myBinaryRight_2 instanceof myBinary)) {
      myExpression _myBinaryRight_3 = it.getMyBinaryRight();
      return this.myValuesCheck(((myBinary) _myBinaryRight_3), att);
    }
    myExpression _myBinaryLeft_4 = it.getMyBinaryLeft();
    if ((_myBinaryLeft_4 instanceof myStringEnum)) {
      myAttribute _myIntentifierIs = att.getMyIntentifierIs();
      final myValue attributeValue = _myIntentifierIs.getMyAttributeContains();
      if ((attributeValue instanceof myStringEnum)) {
        myExpression _myBinaryLeft_5 = it.getMyBinaryLeft();
        boolean _myStringEnumValueCheck = this.myStringEnumValueCheck(((myStringEnum) attributeValue), ((myStringEnum) _myBinaryLeft_5));
        leftCorrect = _myStringEnumValueCheck;
      }
      if ((attributeValue instanceof myBoolean)) {
        myExpression _myBinaryLeft_6 = it.getMyBinaryLeft();
        boolean _myBooleanValueCheck = this.myBooleanValueCheck(((myBoolean) attributeValue), ((myStringEnum) _myBinaryLeft_6));
        leftCorrect = _myBooleanValueCheck;
      }
      myBinaryOparators _oparand = it.getOparand();
      boolean _notEquals = (!Objects.equal(_oparand, myBinaryOparators.OR));
      if (_notEquals) {
        this.error("Operand cannot be other than \'|\'", it, null);
        leftCorrect = false;
      }
    }
    myExpression _myBinaryLeft_7 = it.getMyBinaryLeft();
    if ((_myBinaryLeft_7 instanceof myNumberEnum)) {
      myAttribute _myIntentifierIs_1 = att.getMyIntentifierIs();
      final myValue attributeValue_1 = _myIntentifierIs_1.getMyAttributeContains();
      if ((attributeValue_1 instanceof myNumberEnum)) {
        myExpression _myBinaryLeft_8 = it.getMyBinaryLeft();
        boolean _myNumberEnumValueCheck = this.myNumberEnumValueCheck(((myNumberEnum) attributeValue_1), ((myNumberEnum) _myBinaryLeft_8));
        leftCorrect = _myNumberEnumValueCheck;
      }
      if ((attributeValue_1 instanceof myRange)) {
        myExpression _myBinaryLeft_9 = it.getMyBinaryLeft();
        boolean _myRangeValueCheck = this.myRangeValueCheck(((myRange) attributeValue_1), ((myNumberEnum) _myBinaryLeft_9));
        leftCorrect = _myRangeValueCheck;
      }
    }
    myExpression _myBinaryRight_4 = it.getMyBinaryRight();
    if ((_myBinaryRight_4 instanceof myStringEnum)) {
      myAttribute _myIntentifierIs_2 = att.getMyIntentifierIs();
      final myValue attributeValue_2 = _myIntentifierIs_2.getMyAttributeContains();
      if ((attributeValue_2 instanceof myStringEnum)) {
        myExpression _myBinaryRight_5 = it.getMyBinaryRight();
        boolean _myStringEnumValueCheck_1 = this.myStringEnumValueCheck(((myStringEnum) attributeValue_2), ((myStringEnum) _myBinaryRight_5));
        rightCorrect = _myStringEnumValueCheck_1;
      }
      if ((attributeValue_2 instanceof myBoolean)) {
        myExpression _myBinaryRight_6 = it.getMyBinaryRight();
        boolean _myBooleanValueCheck_1 = this.myBooleanValueCheck(((myBoolean) attributeValue_2), ((myStringEnum) _myBinaryRight_6));
        rightCorrect = _myBooleanValueCheck_1;
      }
    }
    myExpression _myBinaryRight_7 = it.getMyBinaryRight();
    if ((_myBinaryRight_7 instanceof myNumberEnum)) {
      myAttribute _myIntentifierIs_3 = att.getMyIntentifierIs();
      final myValue attributeValue_3 = _myIntentifierIs_3.getMyAttributeContains();
      if ((attributeValue_3 instanceof myNumberEnum)) {
        myExpression _myBinaryRight_8 = it.getMyBinaryRight();
        boolean _myNumberEnumValueCheck_1 = this.myNumberEnumValueCheck(((myNumberEnum) attributeValue_3), ((myNumberEnum) _myBinaryRight_8));
        rightCorrect = _myNumberEnumValueCheck_1;
      }
      if ((attributeValue_3 instanceof myRange)) {
        myExpression _myBinaryRight_9 = it.getMyBinaryRight();
        boolean _myRangeValueCheck_1 = this.myRangeValueCheck(((myRange) attributeValue_3), ((myNumberEnum) _myBinaryRight_9));
        rightCorrect = _myRangeValueCheck_1;
      }
    }
    if ((leftCorrect && rightCorrect)) {
      return true;
    }
    return false;
  }
  
  public boolean myStringEnumValueCheck(final myStringEnum it, final myStringEnum expectedValue) {
    EList<String> _values = it.getValues();
    EList<String> _values_1 = expectedValue.getValues();
    final boolean res = _values.containsAll(_values_1);
    return res;
  }
  
  public boolean myNumberEnumValueCheck(final myNumberEnum it, final myNumberEnum expectedValue) {
    EList<Double> _values = it.getValues();
    EList<Double> _values_1 = expectedValue.getValues();
    final boolean res = _values.containsAll(_values_1);
    return res;
  }
  
  public boolean myBooleanValueCheck(final myBoolean it, final myLiteral expectedValue) {
    final myStringEnum value = ((myStringEnum) expectedValue);
    boolean _or = false;
    String _trueValue = it.getTrueValue();
    EList<String> _values = value.getValues();
    String _get = _values.get(0);
    boolean _equalsIgnoreCase = _trueValue.equalsIgnoreCase(_get);
    if (_equalsIgnoreCase) {
      _or = true;
    } else {
      String _falseValue = it.getFalseValue();
      EList<String> _values_1 = value.getValues();
      String _get_1 = _values_1.get(0);
      boolean _equalsIgnoreCase_1 = _falseValue.equalsIgnoreCase(_get_1);
      _or = _equalsIgnoreCase_1;
    }
    final boolean res = _or;
    return res;
  }
  
  public boolean myRangeValueCheck(final myRange it, final myLiteral expectedValue) {
    if ((expectedValue instanceof myNumberEnum)) {
      EList<Double> _values = ((myNumberEnum)expectedValue).getValues();
      final Function1<Double, Boolean> _function = (Double v) -> {
        boolean _and = false;
        int _from = it.getFrom();
        boolean _lessEqualsThan = (_from <= (v).doubleValue());
        if (!_lessEqualsThan) {
          _and = false;
        } else {
          int _to = it.getTo();
          boolean _lessEqualsThan_1 = ((v).doubleValue() <= _to);
          _and = _lessEqualsThan_1;
        }
        return Boolean.valueOf(_and);
      };
      final boolean res = IterableExtensions.<Double>forall(_values, _function);
      return res;
    }
    if ((expectedValue instanceof myRange)) {
      boolean _and = false;
      int _from = it.getFrom();
      int _from_1 = ((myRange)expectedValue).getFrom();
      boolean _lessEqualsThan = (_from <= _from_1);
      if (!_lessEqualsThan) {
        _and = false;
      } else {
        int _to = ((myRange)expectedValue).getTo();
        int _to_1 = it.getTo();
        boolean _lessEqualsThan_1 = (_to <= _to_1);
        _and = _lessEqualsThan_1;
      }
      final boolean res_1 = _and;
      return res_1;
    }
    return false;
  }
}
